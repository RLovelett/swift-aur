From 6259c12bf444f7b24b0c9ca56a02b6462bf22257 Mon Sep 17 00:00:00 2001
From: Ryan Lovelett <ryan@lovelett.me>
Date: Mon, 28 Dec 2015 16:01:15 -0500
Subject: [PATCH 4/6] [gyb] Decode byte object to string for compatibility with
 Python 3

Python 3's regular expression matching engine seems to be more strict
than Python 2's matching engine. In that in Python 2 the match would
work on both a byte object or string. In Python 3 this results in a
TypeError.

To work around this the loop has been refactored to be a generator that
first decodes each line into a UTF-8 encoded string. This allows the
regular expressions and the associated string operations to continue to
work.

http://stackoverflow.com/a/16422163/247730
http://stackoverflow.com/a/10458567/247730
http://stackoverflow.com/a/606199/247730
---
 lib/ClangImporter/SortedCFDatabase.def.gyb | 2 +-
 utils/GYBUnicodeDataUtils.py               | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/lib/ClangImporter/SortedCFDatabase.def.gyb b/lib/ClangImporter/SortedCFDatabase.def.gyb
index 0cfa84e..44f3f57 100644
--- a/lib/ClangImporter/SortedCFDatabase.def.gyb
+++ b/lib/ClangImporter/SortedCFDatabase.def.gyb
@@ -27,7 +27,7 @@ lineForName = {}
 
 # Load the data file.
 with open(CFDatabaseFile, 'rb') as f:
-  for line in f:
+  for line in [line_bytes.decode('utf-8') for line_bytes in f]:
     # Pass through preprocessor directives literally.
     # Assume that they all fall into either a strict prologue or epilogue.
     if re.match('^#', line):
diff --git a/utils/GYBUnicodeDataUtils.py b/utils/GYBUnicodeDataUtils.py
index a4f76c6..cd92d4f 100644
--- a/utils/GYBUnicodeDataUtils.py
+++ b/utils/GYBUnicodeDataUtils.py
@@ -64,12 +64,12 @@ class GraphemeClusterBreakPropertyTable(UnicodeProperty):
         # values to symbolic values.
         self.symbolic_values = \
             [ None ] * (max(self.numeric_value_table.values()) + 1)
-        for k,v in self.numeric_value_table.iteritems():
+        for k,v in self.numeric_value_table.items():
             self.symbolic_values[v] = k
 
         # Load the data file.
         with open(grapheme_break_property_file_name, 'rb') as f:
-            for line in f:
+            for line in [line_bytes.decode('utf-8') for line_bytes in f]:
                 # Strip comments.
                 line = re.sub('#.*', '', line)
 
@@ -529,7 +529,7 @@ def get_grapheme_cluster_break_tests_as_UTF8(grapheme_break_test_file_name):
                 # and test separately that we handle ill-formed UTF-8 sequences.
                 if code_point >= 0xd800 and code_point <= 0xdfff:
                     code_point = 0x200b
-                code_point = ('\U%(cp)08x' % { 'cp': code_point }).decode('unicode_escape')
+                code_point = (b'\U%(cp)08x' % { 'cp': code_point }).decode('unicode_escape')
                 as_UTF8_bytes = code_point.encode('utf8')
                 as_UTF8_escaped = ''.join(['\\x%(byte)02x' % { 'byte': ord(byte) } for byte in as_UTF8_bytes])
                 test += as_UTF8_escaped
-- 
2.6.4

